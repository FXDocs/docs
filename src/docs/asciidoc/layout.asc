= Layout

== VBox and HBox
Author: Carl Walker

Layout in JavaFX begins with selecting the right container controls.  The two layout controls I use most often are `VBox` and `HBox`.  `VBox` is a container that arranges its children in a vertical stack.  `HBox` arranges its children in a horizontal row.  The power of these two controls comes from wrapping them and setting a few key properties: alignment, hgrow, and vgrow.

This article will demonstrate these controls through a sample project.   A mockup of the project shows a UI with the following:

* A row of top controls containing a Refresh `Button` and a Sign Out `Hyperlink`,
* A `TableView` that will grow to take up the extra vertical space, and
* A Close `Button`.

The UI also features a `Separator` which divides the top part of the screen with what may become a standard lower panel (Save `Button`, Cancel `Button`, etc) for the application.

image::images/layout/vboxandhboxapp_mockup.png[title="Mockup"]

=== Structure

A `VBox` is the outermost container "vbox".  This will be the `Parent` provided to the Scene.  Simply putting UI controls in this `VBox` will allow the controls -- most notably the `TableView` -- to stretch to fit the available horizontal space.  The top controls, the Refresh `Button` and the Sign Out `Hyperlink`, are wrapped in an `HBox`.  Similarly, I wrap the bottom Close `Button` in an `HBox`, allowing for additional Buttons.

[source,java]
----
VBox vbox = new VBox();

Button btnRefresh = new Button("Refresh");

HBox topRightControls = new HBox();
topRightControls.getChildren().add( signOutLink );

topControls.getChildren().addAll( btnRefresh, topRightControls );

TableView<Customer> tblCustomers = new TableView<>();
Separator sep = new Separator();

HBox bottomControls = new HBox();

Button btnClose = new Button("Close");

bottomControls.getChildren().add( btnClose );

vbox.getChildren().addAll(
        topControls,
        tblCustomers,
        sep,
        bottomControls
);
----

This picture shows the mockup broken down by container.  The parent `VBox` is the outermost blue rectangle.  The HBoxes are the inner rectangles (red and green).

image::images/layout/vboxandhboxapp_brokendown.png[title="Mockup Broken Down"]

=== Alignment and Hgrow

The Refresh `Button` is aligned to the left while the Sign Out `Hyperlink` is aligned to the right.  This is accomplished using two HBoxes.  topControls is an `HBox` that contains the Refresh `Button` and also contains an `HBox` with the Sign Out `Hyperlink`.  As the screen grows wider, the Sign Out `Hyperlink` will be pulled to the right while the Refresh `Button` will retain its left alignment.

Alignment is the property that tells a container where to position a control.  topControls sets alignment to the BOTTOM_LEFT.  topRightControls sets alignment to the BOTTOM_RIGHT.  "BOTTOM" makes sure that the baseline of the text "Refresh" matches the baseline of the text "Sign Out".

In order to make the Sign Out `Hyperlink` move to the right when the screen gets wider, `Priority.ALWAYS` is needed.  This is a cue to the JavaFX to widen topRightControls.  Otherwise, topControls will keep the space and topRightControls will appear to the left.  Sign Out `Hyperlink` still would be right-aligned but in a narrower container.

Notice that `setHgrow()` is a static method and neither invoked on the topControls `HBox` nor on itself, topRightControls.  This is a facet of the JavaFX API that can be confusing because most of the API sets properties via setters on objects.

[source,java]
----
topControls.setAlignment( Pos.BOTTOM_LEFT );

HBox.setHgrow(topRightControls, Priority.ALWAYS );
topRightControls.setAlignment( Pos.BOTTOM_RIGHT );
----

Close `Button` is wrapped in an `HBox` and positioned using the BOTTOM_RIGHT priority.

[source,java]
----
bottomControls.setAlignment(Pos.BOTTOM_RIGHT );
----

=== Vgrow

Since the outermost container is `VBox`, the child `TableView` will expand to take up extra horizontal space when the window is widened.  However, vertically resizing the window will produce a gap at the bottom of the screen.  The `VBox` does not automatically resize any of its children.  As with the topRightControls `HBox`, a grow indicator can be set.  In the case of the `HBox`, this was a horizontal resizing instruction setHgrow().  For the `TableView` container `VBox`, this will be setVgrow().

[source,java]
----
VBox.setVgrow( tblCustomers, Priority.ALWAYS );
----

=== Margin

There are a few ways to space out UI controls.  This article uses the margin property on several of the containers to add whitespace around the controls.  These are set individually rather than using a spacing on the `VBox` so that the Separator will span the entire width.

[source,java]
----
VBox.setMargin( topControls, new Insets(10.0d) );
VBox.setMargin( tblCustomers, new Insets(0.0d, 10.0d, 10.0d, 10.0d) );
VBox.setMargin( bottomControls, new Insets(10.0d) );
----

The `Insets` used by tblCustomers omits any top spacing to keep the spacing even.  JavaFX does not consolidate whitespace as in web design.  If the top Inset were set to 10.0d for the `TableView`, the distance between the top controls and the `TableView` would be twice as wide as the distance between any of the other controls.

Notice that these are static methods like the `Priority`.

This picture shows the application when run in its initial 800x600 size.

image::images/layout/vboxandhboxapp_screenshot.png[title="Screenshot"]

This image shows the application resized to a smaller height and width.

image::images/layout/vboxandhboxapp_screenshot_sm.png[title="Screenshot (Small)"]

=== Select the Right Containers

The philosophy of JavaFX layout is the same as the philosophy of Swing.  Select the right container for the task at hand.  This article presented the two most versatile containers: `VBox` and HBox.  By setting properties like alignment, hgrow, and vgrow, you can build incredibly complex layouts through nesting.  These are the containers I use the most and often are the only containers that I need.

=== Complete Code

The code can be tested in a pair of .java files.  There is a POJO for the Customer object used by the `TableView`

[source,java]
----
public class Customer {

    private String firstName;
    private String lastName;

    public Customer(String firstName,
                    String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
----

This is the completed JavaFX `Application` subclass and main.

[source,java]
----
public class VBoxAndHBoxApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        VBox vbox = new VBox();

        HBox topControls = new HBox();
        VBox.setMargin( topControls, new Insets(10.0d) );
        topControls.setAlignment( Pos.BOTTOM_LEFT );

        Button btnRefresh = new Button("Refresh");

        HBox topRightControls = new HBox();
        HBox.setHgrow(topRightControls, Priority.ALWAYS );
        topRightControls.setAlignment( Pos.BOTTOM_RIGHT );
        Hyperlink signOutLink = new Hyperlink("Sign Out");
        topRightControls.getChildren().add( signOutLink );

        topControls.getChildren().addAll( btnRefresh, topRightControls );

        TableView<Customer> tblCustomers = new TableView<>();
        tblCustomers.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        VBox.setMargin( tblCustomers, new Insets(0.0d, 10.0d, 10.0d, 10.0d) );
        VBox.setVgrow( tblCustomers, Priority.ALWAYS );

        TableColumn<Customer, String> lastNameCol = new TableColumn<>("Last Name");
        lastNameCol.setCellValueFactory(new PropertyValueFactory<>("lastName"));

        TableColumn<Customer, String> firstNameCol = new TableColumn<>("First Name");
        firstNameCol.setCellValueFactory(new PropertyValueFactory<>("firstName"));

        tblCustomers.getColumns().addAll( lastNameCol, firstNameCol );

        Separator sep = new Separator();

        HBox bottomControls = new HBox();
        bottomControls.setAlignment(Pos.BOTTOM_RIGHT );
        VBox.setMargin( bottomControls, new Insets(10.0d) );

        Button btnClose = new Button("Close");

        bottomControls.getChildren().add( btnClose );

        vbox.getChildren().addAll(
                topControls,
                tblCustomers,
                sep,
                bottomControls
        );

        Scene scene = new Scene(vbox );

        primaryStage.setScene( scene );
        primaryStage.setWidth( 800 );
        primaryStage.setHeight( 600 );
        primaryStage.setTitle("VBox and HBox App");
        primaryStage.setOnShown( (evt) -> loadTable(tblCustomers) );
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }

    private void loadTable(TableView<Customer> tblCustomers) {
        tblCustomers.getItems().add(new Customer("George", "Washington"));
        tblCustomers.getItems().add(new Customer("Abe", "Lincoln"));
        tblCustomers.getItems().add(new Customer("Thomas", "Jefferson"));
    }
}
----

== Absolute Positioning with Pane
Author: Carl Walker

Containers like `VBox` or `BorderPane` align and distribute their children.  The superclass `Pane` is also a container, but does not impose an order on its children.  The children position themselves through properties like x, centerX, and layoutX.  This is called absolute positioning and it is a technique to place a `Shape` or a `Node` at a certain location on the screen.

This screenshot shows an About View.  The About View contains a `Hyperlink` in the middle of the screen "About this App".  The About View uses several JavaFX shapes to form a design which is cropped to appear like a business card.

image::images/layout/paneapp_about_view.png[title="Screenshot of About View in PaneApp"]

=== Pane Size

Unlike most containers, `Pane` resizes to fit its contents and not the other way around.  This picture is a screenshot from Scenic View taken prior to adding the lower-right Arc.  The `Pane` is the yellow highlighted area.  Notice that it does not take up the full `Stage`.

image::images/layout/paneapp_pane_size_scenicview.png[title="Scenic View Highlighting Partially Built Screen"]

This is a screenshot taken after the lower-right `Arc` was added.  This `Arc` was placed closer to the bottom-right edge of the `Stage`.  This forces the Pane to stretch to accommodate the expanded contents.

image::images/layout/paneapp_scenicview_full_stage.png[title="Scenic View Highlighting Expanded Pane"]

=== The Pane

The outermost container of the About View is a `VBox` whose sole contents are the `Pane`.  The `VBox` is used to fit the entire `Stage` and provides a background.

[source,java]
----
VBox vbox = new VBox();
vbox.setPadding( new Insets( 10 ) );
vbox.setBackground( 
    new Background(
        new BackgroundFill(Color.BLACK, new CornerRadii(0), new Insets(0))
        ));

Pane p = new Pane();
----

=== The Shapes

In the upper left of the screen, there is a group of 4 'Arcs' and 1 'Circle'.  This code positions largeArc at (0,0) through the centerX and centerY arguments in the `Arc` constructor.  Notice that backgroundArc is also positioned at (0,0) and appears underneath largeArc.  `Pane` does not attempt to deconflict overlapping shapes and in this case, overlapping is what is wanted.  smArc1 is placed at (0,160) which is down on the Y axis.  smArc2 is positioned at (160,0) which is right on the X axis.  smCircle is positioned at the same distance as smArc1 and smArc2, but at a 45 degree angle.

[source,java]
----
Arc largeArc = new Arc(0, 0, 100, 100, 270, 90);
largeArc.setType(ArcType.ROUND);

Arc backgroundArc = new Arc(0, 0, 160, 160, 270, 90 );
backgroundArc.setType( ArcType.ROUND );

Arc smArc1 = new Arc( 0, 160, 30, 30, 270, 180);
smArc1.setType(ArcType.ROUND);

Circle smCircle = new Circle(160/Math.sqrt(2.0), 160/Math.sqrt(2.0), 30,Color.web("0xF2A444"));

Arc smArc2 = new Arc( 160, 0, 30, 30, 180, 180);
smArc2.setType(ArcType.ROUND);
----

The lower-right `Arc` is positioned based on the overall height of the `Stage`.  The 20 subtracted from the height is the 10 pixel `Insets` from the `VBox` (10 for left + 10 for right).

[source,java]
----
Arc medArc = new Arc(568-20, 320-20, 60, 60, 90, 90);
medArc.setType(ArcType.ROUND);

primaryStage.setWidth( 568 );
primaryStage.setHeight( 320 );
----

=== The Hyperlink

The `Hyperlink` is positioned offset the center (284,160) which is the width and height of the `Stage` both divided by two.  This positions the text of the `Hyperlink` in the lower-right quadrant of the screen, so an offset is needed based on the `Hyperlink` width and height.  The dimensions are not available for the `Hyperlink` until the screen is shown, so I make a post-shown adjustment to the position.

[source,java]
----
Hyperlink hyperlink = new Hyperlink("About this App");

primaryStage.setOnShown( (evt) -> {
     hyperlink.setLayoutX( 284 - (hyperlink.getWidth()/3) );
     hyperlink.setLayoutY( 160 - hyperlink.getHeight() );
});
----

The `Hyperlink` is not placed in the true center of the screen.  The layoutX value is based on a divide-by-three operation that moves it away from the upper-left design.

=== Z-Order

As mentioned earlier, `Pane` supports overlapping children.  This picture shows the About View with depth added to the upper-left design.  The smaller `Arcs` and `Circle` hover over backgroundArc as does largeArc.

image::images/layout/paneapp_zorder.png[title="About View Showing Depth"]

The z-order in this example is determined by the order in which the children are added to the `Pane`.  backgroundArc is obscured by items added later, most notably largeArc.  To rearrange the children, use the toFront() and toBack() methods after the items have been added to the `Pane`.

[source,java]
----
p.getChildren().addAll( backgroundArc, largeArc, smArc1, smCircle, smArc2, hyperlink, medArc );

vbox.getChildren().add( p );
----

When starting JavaFX, it is tempting to build an absolute layout.  Be aware that absolute layouts are brittle, often breaking when the screen is resized or when items are added during the software maintenance phase.  Yet, there are good reasons for using absolute positioning.  Gaming is one such usage.  In a game, you can adjust the (x,y) coordinate of a 'Shape' to move a game piece around the screen.  This article demonstrated the JavaFX class `Pane` which provides absolute positioning to any shape-driven UI.

=== Completed Code

This is the completed JavaFX `Application` subclass and main.

[source,java]
----
public class PaneApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        VBox vbox = new VBox();
        vbox.setPadding( new Insets( 10 ) );
        vbox.setBackground( 
            new Background(
                new BackgroundFill(Color.BLACK, new CornerRadii(0), new Insets(0))
                ));

        Pane p = new Pane();

        Arc largeArc = new Arc(0, 0, 100, 100, 270, 90);
        largeArc.setFill(Color.web("0x59291E"));
        largeArc.setType(ArcType.ROUND);

        Arc backgroundArc = new Arc(0, 0, 160, 160, 270, 90 );
        backgroundArc.setFill( Color.web("0xD96F32") );
        backgroundArc.setType( ArcType.ROUND );

        Arc smArc1 = new Arc( 0, 160, 30, 30, 270, 180);
        smArc1.setFill(Color.web("0xF2A444"));
        smArc1.setType(ArcType.ROUND);

        Circle smCircle = new Circle(
            160/Math.sqrt(2.0), 160/Math.sqrt(2.0), 30,Color.web("0xF2A444")
            );

        Arc smArc2 = new Arc( 160, 0, 30, 30, 180, 180);
        smArc2.setFill(Color.web("0xF2A444"));
        smArc2.setType(ArcType.ROUND);

        Hyperlink hyperlink = new Hyperlink("About this App");
        hyperlink.setFont( Font.font(36) );
        hyperlink.setTextFill( Color.web("0x3E6C93") );
        hyperlink.setBorder( Border.EMPTY );

        Arc medArc = new Arc(568-20, 320-20, 60, 60, 90, 90);
        medArc.setFill(Color.web("0xD9583B"));
        medArc.setType(ArcType.ROUND);

        p.getChildren().addAll( backgroundArc, largeArc, smArc1, smCircle, 
            smArc2, hyperlink, medArc );

        vbox.getChildren().add( p );

        Scene scene = new Scene(vbox);
        scene.setFill(Color.BLACK);

        primaryStage.setTitle("Pane App");
        primaryStage.setScene( scene );
        primaryStage.setWidth( 568 );
        primaryStage.setHeight( 320 );
        primaryStage.setOnShown( (evt) -> {
             hyperlink.setLayoutX( 284 - (hyperlink.getWidth()/3) );
             hyperlink.setLayoutY( 160 - hyperlink.getHeight() );
        });
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== Clipping
Author: Christoph Nahr

Most JavaFX layout containers (base class https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Region.html[Region]) automatically position and size their children, so clipping any child contents that might protrude beyond the container’s layout bounds is never an issue. The big exception is https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Pane.html[Pane], a direct subclass of `Region` and the base class for all layout containers with publicly accessible children. Unlike its subclasses Pane does not attempt to arrange its children but simply accepts explicit user positioning and sizing.

This makes `Pane` suitable as a drawing surface, similar to https://docs.oracle.com/javase/8/javafx/api/javafx/scene/canvas/Canvas.html[Canvas] but rendering user-defined https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Shape.html[Shape] children rather than direct drawing commands. The problem is that drawing surfaces are usually expected to automatically clip their contents at their bounds. `Canvas` does this by default but `Pane` does not. From the last paragraph of the Javadoc entry for `Pane`:

[quote]
Pane does not clip its content by default, so it is possible that children’s bounds may extend outside its own bounds, either if children are positioned at negative coordinates or the pane is resized smaller than its preferred size.

This quote is somewhat misleading. Children are rendered (wholly or partially) outside their parent `Pane` 'whenever' their combination of position and size extends beyond the parent’s bounds, regardless of whether the position is negative or the `Pane` is ever resized. Quite simply, `Pane` only provides a coordinate shift to its children, based on its upper-left corner – but its layout bounds are completely ignored while rendering children. Note that the Javadoc for all `Pane` subclasses (that I checked) includes a similar warning. They don’t clip their contents either, but as mentioned above this is not usually a problem for them because they automatically arrange their children.

So to properly use `Pane` as a drawing surface for `Shapes`, we need to manually clip its contents. This is somewhat complex, especially when a visible border is involved. I wrote a small demo application to illustrate the default behavior and various steps to fix it. You can download it as http://kynosarges.org/misc/PaneDemo.zip[PaneDemo.zip] which contains a project for NetBeans 8.2 and Java SE 8u112. The following sections explain each step with screenshots and pertinent code snippets.

=== Default Behavior

Starting up, PaneDemo shows what happens when you put an `Ellipse` shape into a `Pane` that’s too small to contain it entirely. The `Pane` has a nice thick rounded https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Border.html[Border] to visualize its area. The application window is resizable, with the `Pane` size following the window size. The three buttons on the left are used to switch to the other steps in the demo; click Default (Alt+D) to revert to the default output from a later step.

image::images/layout/clipping_extends.png[title="Child Extending Outside Pane Bounds"]

As you can see, the `Ellipse` overwrites its parent’s `Border` and protrudes well beyond it. The following code is used to generate the default view. It’s split into several smaller methods, and a constant for the `Border` corner radius, because they will be referenced in the next steps.

[source,java]
----
static final double BORDER_RADIUS = 4;
 
static Border createBorder() {
    return new Border(
            new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID,
            new CornerRadii(BORDER_RADIUS), BorderStroke.THICK));
}
 
static Shape createShape() {
    final Ellipse shape = new Ellipse(50, 50);
    shape.setCenterX(80);
    shape.setCenterY(80);
    shape.setFill(Color.LIGHTCORAL);
    shape.setStroke(Color.LIGHTCORAL);
    return shape;
}
 
static Region createDefault() {
    final Pane pane = new Pane(createShape());
    pane.setBorder(createBorder());
    pane.setPrefSize(100, 100);
    return pane;
}
----

=== Simple Clipping

Surprisingly, there is no predefined option to have a resizable `Region` automatically clip its children to its current size. Instead, you need to use the basic https://docs.oracle.com/javase/8/javafx/api/javafx/scene/Node.html#clipProperty[clipProperty] defined on `Node` and keep it updated manually to reflect changing layout bounds. Method `clipChildren` below show how this works (with Javadoc because you may want to reuse it in your own code):

[source,java]
----
/**
 * Clips the children of the specified {@link Region} to its current size.
 * This requires attaching a change listener to the region’s layout bounds,
 * as JavaFX does not currently provide any built-in way to clip children.
 * 
 * @param region the {@link Region} whose children to clip
 * @param arc the {@link Rectangle#arcWidth} and {@link Rectangle#arcHeight}
 *            of the clipping {@link Rectangle}
 * @throws NullPointerException if {@code region} is {@code null}
 */
static void clipChildren(Region region, double arc) {
 
    final Rectangle outputClip = new Rectangle();
    outputClip.setArcWidth(arc);
    outputClip.setArcHeight(arc);
    region.setClip(outputClip);
 
    region.layoutBoundsProperty().addListener((ov, oldValue, newValue) -> {
        outputClip.setWidth(newValue.getWidth());
        outputClip.setHeight(newValue.getHeight());
    });        
}
 
static Region createClipped() {
    final Pane pane = new Pane(createShape());
    pane.setBorder(createBorder());
    pane.setPrefSize(100, 100);
 
    // clipped children still overwrite Border!
    clipChildren(pane, 3 * BORDER_RADIUS);
 
    return pane;
}
----

Choose Clipped (Alt+C) in PaneDemo to render the corresponding output. Here’s how that looks:

image::images/layout/clipping_clipped.png[title="Pane with Clip Applied"]

That’s better. The `Ellipse` no longer protrudes beyond the `Pane` – but still overwrites its Border. Also note that we had to manually specify an estimated corner rounding for the clipping `Rectangle` in order to reflect the rounded `Border` corners. This estimate is 3 * BORDER_RADIUS because the corner radius specified on `Border` actually defines its inner radius, and the outer radius (which we need here) will be greater depending on the `Border` thickness. (You could compute the outer radius exactly if you really wanted to, but I skipped that for the demo application.)

=== Nested Panes

Can we somehow specify a clipping region that excludes a visible` Border`? Not on the drawing `Pane` itself, as far as I can tell. The clipping region affects the `Border` as well as other contents, so if you were to shrink the clipping region to exclude it you would no longer see any `Border` at all. Instead, the solution is to create two nested panes: one inner drawing `Pane` without `Border` that clips exactly to its bounds, and one outer `StackPane` that defines the visible `Border` and also resizes the drawing `Pane`. Here is the final code:

[source,java]
----
static Region createNested() {
    // create drawing Pane without Border or size
    final Pane pane = new Pane(createShape());
    clipChildren(pane, BORDER_RADIUS);
 
    // create sized enclosing Region with Border
    final Region container = new StackPane(pane);
    container.setBorder(createBorder());
    container.setPrefSize(100, 100);
    return container;
}
----

Choose Nested (Alt+N) in PaneDemo to render the corresponding output. Now everything looks as it should:

image::images/layout/clipping_nested.png[title="Nesting Pane in StackPane"]

As an added bonus, we no longer need to guesstimate a correct corner radius for the clipping `Rectangle`. We now clip to the inner rather than outer circumference of our visible `Border`, so we can directly reuse its inner corner radius. Should you specify multiple different corner radii or an otherwise more complex `Border` you’d have to define a correspondingly more complex clipping `Shape`.

There is one small caveat. The top-left corner of the drawing `Pane` to which all child coordinates are relative now starts _within_ the visible `Border`. If you retroactively change a single `Pane` with visible `Border` to nested panes as shown here, all children will exhibit a slight positioning shift corresponding to the `Border` thickness.

== GridPane
Author: Carl Walker

Forms in business applications often use a layout that mimics a database record.  For each column in a table, a header is added on the left-hand side which is matched with a row value on the right-hand side. JavaFX has a special purpose control called `GridPane` for this type of layout that keeps contents aligned by row and column.  `GridPane` also supports spanning for more complex layouts.

This screenshot shows a basic `GridPane` layout.  On the left-hand side of the form, there is a column of field names: Email, Priority, Problem, Description.  On the right-hand side of the form, there is a column of controls which will display the value of the corresponding field.  The field names are of type `Label` and the value controls are a mixture including `TextField`, `TextArea`, and `ComboBox`.

image::images/layout/gridpaneapp.png[title="Field Name / Value Pairs in a GridPane"]

The following code shows the objects created for the form. "vbox" is the root of the `Scene` and will also contain the `ButtonBar` at the base of the form.

[source,java]
----
VBox vbox = new VBox();

GridPane gp = new GridPane();

Label lblTitle = new Label("Support Ticket");

Label lblEmail = new Label("Email");
TextField tfEmail = new TextField();

Label lblPriority = new Label("Priority");
ObservableList<String> priorities = FXCollections.observableArrayList("Medium", "High", "Low");
ComboBox<String> cbPriority = new ComboBox<>(priorities);

Label lblProblem = new Label("Problem");
TextField tfProblem = new TextField();

Label lblDescription = new Label("Description");
TextArea taDescription = new TextArea();
----

GridPane has a handy method `setGridLinesVisible()` which shows the grid structure and gutters.  It is especially useful in more complex layouts where spanning is involved because gaps in the row/col assignments can cause shifts in the layout.

image::images/layout/gridpaneapp_lines.png[title="Grid Structure and Gutters"]

=== Spacing

As a container, `GridPane` has a padding property that can be set to surround the `GridPane` contents with whitespace.  "padding" will take an `Inset` object as a parameter.  In this example, 10 pixels of whitespace is applied to all sides so a short form constructor is used for `Inset`.

Within the `GridPane`, vgap and hgap control the gutters.  The hgap is set to 4 to keep the fields close to their values.  vgap is slightly larger to help with mouse navigation.

[source,java]
----
gp.setPadding( new Insets(10) );
gp.setHgap( 4 );
gp.setVgap( 8 );
----

In order to keep the lower part of the form consistent, a `Priority` is set on the VBox.  This will _not resize_ the individual rows however.  For individual resize specifications, use `ColumnConstraints` and `RowConstraints`.

[source,java]
----
VBox.setVgrow(gp, Priority.ALWAYS );
----

=== Adding Items

Unlike containers like `BorderPane` or `HBox`, Nodes need to specify their position within the `GridPane`.  This is done with the `add()` method on the `GridPane` and not the add method on a container children property.  This form of the `GridPane` `add()` method takes a zero-based column position and a zero-based row position.  This code puts two statements on the same line for readability.

[source,java]
----
gp.add( lblTitle,       1, 1);  // empty item at 0,0
gp.add( lblEmail,       0, 2); gp.add(tfEmail,        1, 2);
gp.add( lblPriority,    0, 3); gp.add( cbPriority,    1, 3);
gp.add( lblProblem,     0, 4); gp.add( tfProblem,     1, 4);
gp.add( lblDescription, 0, 5); gp.add( taDescription, 1, 5);
----

lblTitle is put in the second column of the first row.  There is no entry in the first column of the first row.

Subsequent additions are presented in pairs.  Field name `Label` objects are put in the first column (column index=0) and value controls are put in the second column (column index=1).  The rows are added by the incremented second value.  For example, lblPriority is put in the fourth row along with its `ComboBox`.

`GridPane` is an important container in JavaFX business application design.  When you have a requirement for name / value pairs, `GridPane` will be an easy way to support the strong column orientation of a traditional form.

=== Completed Code

The following class is the complete code form the example.  This include the definition of the `ButtonBar` which was not presented in the preceding sections focused on `GridPane`.

[source,java]
----
public class GridPaneApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        VBox vbox = new VBox();

        GridPane gp = new GridPane();
        gp.setPadding( new Insets(10) );
        gp.setHgap( 4 );
        gp.setVgap( 8 );

        VBox.setVgrow(gp, Priority.ALWAYS );

        Label lblTitle = new Label("Support Ticket");

        Label lblEmail = new Label("Email");
        TextField tfEmail = new TextField();

        Label lblPriority = new Label("Priority");
        ObservableList<String> priorities = 
            FXCollections.observableArrayList("Medium", "High", "Low");
        ComboBox<String> cbPriority = new ComboBox<>(priorities);

        Label lblProblem = new Label("Problem");
        TextField tfProblem = new TextField();

        Label lblDescription = new Label("Description");
        TextArea taDescription = new TextArea();

        gp.add( lblTitle,       1, 1);  // empty item at 0,0
        gp.add( lblEmail,       0, 2); gp.add(tfEmail,        1, 2);
        gp.add( lblPriority,    0, 3); gp.add( cbPriority,    1, 3);
        gp.add( lblProblem,     0, 4); gp.add( tfProblem,     1, 4);
        gp.add( lblDescription, 0, 5); gp.add( taDescription, 1, 5);

        Separator sep = new Separator(); // hr

        ButtonBar buttonBar = new ButtonBar();
        buttonBar.setPadding( new Insets(10) );

        Button saveButton = new Button("Save");
        Button cancelButton = new Button("Cancel");

        buttonBar.setButtonData(saveButton, ButtonBar.ButtonData.OK_DONE);
        buttonBar.setButtonData(cancelButton, ButtonBar.ButtonData.CANCEL_CLOSE);

        buttonBar.getButtons().addAll(saveButton, cancelButton);

        vbox.getChildren().addAll( gp, sep, buttonBar );

        Scene scene = new Scene(vbox);

        primaryStage.setTitle("Grid Pane App");
        primaryStage.setScene(scene);
        primaryStage.setWidth( 736 );
        primaryStage.setHeight( 414  );
        primaryStage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== GridPane Spanning
Author: Carl Walker

For more complex forms implemented with `GridPane`, spanning is supported.  Spanning allows a control to claim the space of neighboring columns (colspan) and neighboring rows (rowspan).  This screenshot shows a form that extends the example in the previous section.  The two-column layout of the earlier version has been replaced with a multiple-column layout.  Fields like Problem and Description retain the original structure.  But controls were added to the rows that formerly held only Email and Priority.

image::images/layout/complexgridpaneapp.png[title="Spanning Columns"]

Turing the grid lines on, notice that the former two column grid is replaced with a six column grid.  The third row containing six items -- 3 field name / value pairs -- dictates the structure.  The rest of the form will use spanning in order to fill in the whitespace.

image::images/layout/complexgridpaneapp_lines.png[title="Lines Highlighting Spanning"]

The `VBox` and `GridPane` container objects used in this update follow.  There is a little more Vgap to help the user select the `ComboBox` controls.

[source,java]
----
GridPane gp = new GridPane();
gp.setPadding( new Insets(10) );
gp.setHgap( 4 );
gp.setVgap( 10 );

VBox.setVgrow(gp, Priority.ALWAYS );
----

These are control creation statements from the updated example.

[source,java]
----
Label lblTitle = new Label("Support Ticket");

Label lblEmail = new Label("Email");
TextField tfEmail = new TextField();

Label lblContract = new Label("Contract");
TextField tfContract = new TextField();

Label lblPriority = new Label("Priority");
ObservableList<String> priorities = 
    FXCollections.observableArrayList("Medium", "High", "Low");
ComboBox<String> cbPriority = new ComboBox<>(priorities);

Label lblSeverity = new Label("Severity");
ObservableList<String> severities = 
    FXCollections.observableArrayList("Blocker", "Workaround", "N/A");
ComboBox<String> cbSeverity = new ComboBox<>(severities);

Label lblCategory = new Label("Category");
ObservableList<String> categories = 
    FXCollections.observableArrayList("Bug", "Feature");
ComboBox<String> cbCategory = new ComboBox<>(categories);

Label lblProblem = new Label("Problem");
TextField tfProblem = new TextField();

Label lblDescription = new Label("Description");
TextArea taDescription = new TextArea();
----

As in the earlier version, the controls are added to the `GridPane` using the `add()` method.  A column and row are specified.  In this snippet, the indexing it not straightforward as there are gaps expected to be filled in by spanning content.

[source,java]
----
gp.add( lblTitle,       1, 0);  // empty item at 0,0

gp.add( lblEmail,       0, 1);
gp.add(tfEmail,         1, 1);
gp.add( lblContract,    4, 1 );
gp.add( tfContract,     5, 1 );

gp.add( lblPriority,    0, 2);
gp.add( cbPriority,     1, 2);
gp.add( lblSeverity,    2, 2);
gp.add( cbSeverity,     3, 2);
gp.add( lblCategory,    4, 2);
gp.add( cbCategory,     5, 2);

gp.add( lblProblem,     0, 3); gp.add( tfProblem,     1, 3);
gp.add( lblDescription, 0, 4); gp.add( taDescription, 1, 4);
----

Finally, the spanning definitions are set using a static method on `GridPane`.  There is a similar method to do row spanning.  Title will take up 5 columns as will Problem and Description.  Email shares a row with Contract, but will take up more columns.  The third row of ComboBoxes is a set of three field/value pairs each taking up one column.

[source,java]
----
GridPane.setColumnSpan( lblTitle, 5 );
GridPane.setColumnSpan( tfEmail, 3 );
GridPane.setColumnSpan( tfProblem, 5 );
GridPane.setColumnSpan( taDescription, 5 );
----

Alternatively, a variation of the add() method will columnSpan and rowSpan arguments to avoid the subsequent static method call.

This expanded `GridPane` example demonstrated column spanning.  The same capability is available for row spanning which would allow a control to claim additional vertical space.  Spanning keeps controls aligned even in cases where the number of items in a given row (or column) varies.  To keep the focus on the spanning topic, this grid allowed the column widths to vary.  The article on `ColumnConstraints` and `RowConstraints` will focus on building true modular and column typographical grids by better controlling the columns (and rows).

=== Completed Code

The following is the completed code for the spanning GridPane example.

[source,java]
----
public class ComplexGridPaneApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        VBox vbox = new VBox();

        GridPane gp = new GridPane();
        gp.setPadding( new Insets(10) );
        gp.setHgap( 4 );
        gp.setVgap( 10 );

        VBox.setVgrow(gp, Priority.ALWAYS );

        Label lblTitle = new Label("Support Ticket");

        Label lblEmail = new Label("Email");
        TextField tfEmail = new TextField();

        Label lblContract = new Label("Contract");
        TextField tfContract = new TextField();

        Label lblPriority = new Label("Priority");
        ObservableList<String> priorities = 
            FXCollections.observableArrayList("Medium", "High", "Low");
        ComboBox<String> cbPriority = new ComboBox<>(priorities);

        Label lblSeverity = new Label("Severity");
        ObservableList<String> severities = FXCollections.observableArrayList("Blocker", "Workaround", "N/A");
        ComboBox<String> cbSeverity = new ComboBox<>(severities);

        Label lblCategory = new Label("Category");
        ObservableList<String> categories = FXCollections.observableArrayList("Bug", "Feature");
        ComboBox<String> cbCategory = new ComboBox<>(categories);

        Label lblProblem = new Label("Problem");
        TextField tfProblem = new TextField();

        Label lblDescription = new Label("Description");
        TextArea taDescription = new TextArea();

        gp.add( lblTitle,       1, 0);  // empty item at 0,0

        gp.add( lblEmail,       0, 1);
        gp.add(tfEmail,         1, 1);
        gp.add( lblContract,    4, 1 );
        gp.add( tfContract,     5, 1 );

        gp.add( lblPriority,    0, 2);
        gp.add( cbPriority,     1, 2);
        gp.add( lblSeverity,    2, 2);
        gp.add( cbSeverity,     3, 2);
        gp.add( lblCategory,    4, 2);
        gp.add( cbCategory,     5, 2);

        gp.add( lblProblem,     0, 3); gp.add( tfProblem,     1, 3);
        gp.add( lblDescription, 0, 4); gp.add( taDescription, 1, 4);

        GridPane.setColumnSpan( lblTitle, 5 );
        GridPane.setColumnSpan( tfEmail, 3 );
        GridPane.setColumnSpan( tfProblem, 5 );
        GridPane.setColumnSpan( taDescription, 5 );

        Separator sep = new Separator(); // hr

        ButtonBar buttonBar = new ButtonBar();
        buttonBar.setPadding( new Insets(10) );

        Button saveButton = new Button("Save");
        Button cancelButton = new Button("Cancel");

        buttonBar.setButtonData(saveButton, ButtonBar.ButtonData.OK_DONE);
        buttonBar.setButtonData(cancelButton, ButtonBar.ButtonData.CANCEL_CLOSE);

        buttonBar.getButtons().addAll(saveButton, cancelButton);

        vbox.getChildren().addAll( gp, sep, buttonBar );

        Scene scene = new Scene(vbox);

        primaryStage.setTitle("Grid Pane App");
        primaryStage.setScene(scene);
        primaryStage.setWidth( 736 );
        primaryStage.setHeight( 414  );
        primaryStage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== GridPane ColumnConstraints and RowConstraints
Author: Carl Walker

Previous articles on `GridPane` showed how to create a two-column layout with field names on the left-hand side and field values on the right-hand side.  That example was expanded to add more controls to a given row and to use spanning handle gaps in content.  This article introduces a pair of JavaFX classes `ColumnConstraints` and `RowConstraints`.  These classes give additional specification to a row or column.  In this example, a row containing a `TextArea` will be given all extra space when the window is resized.  The two columns will be set to equals widths.

This screenshot shows an example modified from previous articles.  The demo program for this article has a rotated feel whereby the field names are paired with the field values vertically (on top of the values) rather than horizontally.  Row spanning and column spanning is used to align items that are larger than a single cell.

[[initial_image]]
image::images/layout/constraintsgridpaneapp_1_annotated.png[title="Example App Using Row and Column Spanning"]

The red rectangles and text are not part of the UI.  They are identifying sections of the screen that will be addressed later with ColumnConstraints and RowConstaints.

This code is the creation of the `Scene` root and `GridPane` objects.

[source,java]
----
VBox vbox = new VBox();

GridPane gp = new GridPane();
gp.setPadding( new Insets(10) );
gp.setHgap( 4 );
gp.setVgap( 10 );

VBox.setVgrow(gp, Priority.ALWAYS );
----

This code creates the UI controls objects used in the article.  Notice that Priority is now implemented as a `VBox` containing RadioButtons.

[source,java]
----
Label lblTitle = new Label("Support Ticket");

Label lblEmail = new Label("Email");
TextField tfEmail = new TextField();

Label lblContract = new Label("Contract");
TextField tfContract = new TextField();

Label lblPriority = new Label("Priority");
RadioButton rbMedium = new RadioButton("Medium");
RadioButton rbHigh = new RadioButton("High");
RadioButton rbLow = new RadioButton("Low");
VBox priorityVBox = new VBox();
priorityVBox.setSpacing( 2 );
GridPane.setVgrow(priorityVBox, Priority.SOMETIMES);
priorityVBox.getChildren().addAll( lblPriority, rbMedium, rbHigh, rbLow );

Label lblSeverity = new Label("Severity");
ObservableList<String> severities = 
    FXCollections.observableArrayList("Blocker", "Workaround", "N/A");
ComboBox<String> cbSeverity = new ComboBox<>(severities);

Label lblCategory = new Label("Category");
ObservableList<String> categories = 
    FXCollections.observableArrayList("Bug", "Feature");
ComboBox<String> cbCategory = new ComboBox<>(categories);

Label lblProblem = new Label("Problem");
TextField tfProblem = new TextField();

Label lblDescription = new Label("Description");
TextArea taDescription = new TextArea();
----

The Label and value control pairings of Email, Contract, Problem, and Description are put in a single column.  They should take the full width of the `GridPane` so each has its columnSpan set to 2.

[source,java]
----
GridPane.setColumnSpan( tfEmail, 2 );
GridPane.setColumnSpan( tfContract, 2 );
GridPane.setColumnSpan( tfProblem, 2 );
GridPane.setColumnSpan( taDescription, 2 );
----

The new Priority RadioButtons are matched horizontally with four controls for Severity and Category.  This rowSpan setting instructs JavaFX to put the VBox containing the RadioButton in a merged cell that is four rows in height.

[source,java]
----
GridPane.setRowSpan( priorityVBox, 4 );
----

=== Row Constraints

At this point, the code reflects the UI screenshot presented in <<initial_image>>.  To reallocate the extra space at the base of the form, use a RowConstraints object to set a Priority.ALWAYS on the row of the `TextArea`.  This will result in the `TextArea` growing to fill the available space with something usable.

image::images/layout/constraintsgridpaneapp_description.png[title="TextArea Grows to Fill Extra Space"]

This code is a `RowConstraints` object to the `GridPane` for the `TextArea`.  Prior to the setter, `RowConstraints` objects are allocated for all of the other rows.  The set method of `getRowConstraints()` will throw an index exception when you specify row 12 without first allocating an object.

[source,java]
----
RowConstraints taDescriptionRowConstraints = new RowConstraints();
taDescriptionRowConstraints.setVgrow(Priority.ALWAYS);

for( int i=0; i<13; i++ ) {
    gp.getRowConstraints().add( new RowConstraints() );
}

gp.getRowConstraints().set( 12, taDescriptionRowConstraints );
----

As an alternative syntax, there is a setConstraints() method available from the `GridPane`.  This will pass in several values and obviates the need for the dedicated columnSpan set call for the `TextArea`.  The `RowConstraints` code from the previous listing will not appear in the finished program.

[source,java]
----
gp.setConstraints(taDescription,
                  0, 12,
                  2, 1,
                  HPos.LEFT, VPos.TOP,
                  Priority.SOMETIMES, Priority.ALWAYS);
----

This code identifies the `Node` at (0,12) which is the `TextArea`.  The `TextArea` will span 2 columns but only 1 row.  The HPos and Vpos are set to the TOP LEFT.  Finally, the `Priority` of the hgrow is SOMETIMES and the vgrow is ALWAYS.  Since the `TextArea` is the only row with "ALWAYS", it will get the additional space.  If there were other ALWAYS settings, the space would be shared among multiple rows.

=== Column Constraints

To properly allocate the space surrounding the Severity and Category controls, ColumnConstraints will be specified.  The default behavior allocates less space to the first column because of the smaller Priority RadioButtons.  The following wireframe shows the desired layout which has equal columns separated by a gutter of 4 pixels (Hgap).

image::images/layout/constraintsgridpaneapp_wireframe.png[title="Wireframe of the Demo App"]

To make the column widths equal, define two `ColumnConstraint` objects and use a percentage specifier.

[source,java]
----
ColumnConstraints col1 = new ColumnConstraints();
col1.setPercentWidth( 50 );
ColumnConstraints col2 = new ColumnConstraints();
col2.setPercentWidth( 50 );
gp.getColumnConstraints().addAll( col1, col2 );
----

This is a screenshot of the finished example.

image::images/layout/constraintsgridpaneapp_finished.png[title="App With Extra Space Properly Allocated"]

`GridPane` is an important control in developing JavaFX business applications.  When working on a requirement involving name / value pairs and a single record view, use `GridPane`.  While `GridPane` is easier to use than the `GridBagLayout` from Swing, I still find that the API is a little inconvenient (assigning own indexes, disassociated constraints).  Fortunately, there is Scene Builder which simplifies the construction of this form greatly.

=== Completed Code

The following is the completed code for the constraints GridPane example.

[source,java]
----
public class ConstraintsGridPaneApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        VBox vbox = new VBox();

        GridPane gp = new GridPane();
        gp.setPadding( new Insets(10) );
        gp.setHgap( 4 );
        gp.setVgap( 10 );

        VBox.setVgrow(gp, Priority.ALWAYS );

        Label lblTitle = new Label("Support Ticket");

        Label lblEmail = new Label("Email");
        TextField tfEmail = new TextField();

        Label lblContract = new Label("Contract");
        TextField tfContract = new TextField();

        Label lblPriority = new Label("Priority");
        RadioButton rbMedium = new RadioButton("Medium");
        RadioButton rbHigh = new RadioButton("High");
        RadioButton rbLow = new RadioButton("Low");
        VBox priorityVBox = new VBox();
        priorityVBox.setSpacing( 2 );
        GridPane.setVgrow(priorityVBox, Priority.SOMETIMES);
        priorityVBox.getChildren().addAll( lblPriority, rbMedium, rbHigh, rbLow );

        Label lblSeverity = new Label("Severity");
        ObservableList<String> severities = FXCollections.observableArrayList("Blocker", "Workaround", "N/A");
        ComboBox<String> cbSeverity = new ComboBox<>(severities);

        Label lblCategory = new Label("Category");
        ObservableList<String> categories = FXCollections.observableArrayList("Bug", "Feature");
        ComboBox<String> cbCategory = new ComboBox<>(categories);

        Label lblProblem = new Label("Problem");
        TextField tfProblem = new TextField();

        Label lblDescription = new Label("Description");
        TextArea taDescription = new TextArea();

        gp.add( lblTitle,       0, 0);

        gp.add( lblEmail,       0, 1);
        gp.add(tfEmail,         0, 2);

        gp.add( lblContract,    0, 3 );
        gp.add( tfContract,     0, 4 );

        gp.add( priorityVBox,   0, 5);

        gp.add( lblSeverity,    1, 5);
        gp.add( cbSeverity,     1, 6);
        gp.add( lblCategory,    1, 7);
        gp.add( cbCategory,     1, 8);

        gp.add( lblProblem,     0, 9);
        gp.add( tfProblem,      0, 10);

        gp.add( lblDescription, 0, 11);
        gp.add( taDescription,  0, 12);

        GridPane.setColumnSpan( tfEmail, 2 );
        GridPane.setColumnSpan( tfContract, 2 );
        GridPane.setColumnSpan( tfProblem, 2 );

        GridPane.setRowSpan( priorityVBox, 4 );

        gp.setConstraints(taDescription,
                          0, 12,
                          2, 1,
                          HPos.LEFT, VPos.TOP,
                          Priority.SOMETIMES, Priority.ALWAYS);

        ColumnConstraints col1 = new ColumnConstraints();
        col1.setPercentWidth( 50 );
        ColumnConstraints col2 = new ColumnConstraints();
        col2.setPercentWidth( 50 );
        gp.getColumnConstraints().addAll( col1, col2 );

        Separator sep = new Separator(); // hr

        ButtonBar buttonBar = new ButtonBar();
        buttonBar.setPadding( new Insets(10) );

        Button saveButton = new Button("Save");
        Button cancelButton = new Button("Cancel");

        buttonBar.setButtonData(saveButton, ButtonBar.ButtonData.OK_DONE);
        buttonBar.setButtonData(cancelButton, ButtonBar.ButtonData.CANCEL_CLOSE);

        buttonBar.getButtons().addAll(saveButton, cancelButton);

        vbox.getChildren().addAll( gp, sep, buttonBar );

        Scene scene = new Scene(vbox);

        primaryStage.setTitle("Grid Pane App");
        primaryStage.setScene(scene);
        primaryStage.setWidth( 414 );
        primaryStage.setHeight( 736  );
        primaryStage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== AnchorPane
Author: Carl Walker

`AnchorPane` is a container control that defines its layout in terms of edges.  When placed in a container, the `AnchorPane` stretches to fill the available space.  The children of `AnchorPane` express their positions and sizes as distances from the edges: Top, Left, Bottom, Right.  If one or two anchor settings are placed on an `AnchorPane` child, the child will be fixed to that corner of the window.  If more than two anchor settings are used, the child will be stretched to fill the available horizontal and vertical space.

This mockup shows a `TextArea` surrounded by a set of controls: a `Hyperlink` and two status indicators.  Since the `TextArea` will contain all of the content, it should take up most of the space initially and should acquire any additional space from a resize.  On the periphery, there is a `Hyperlink` in the upper-right, a connection `Label` and `Circle` in the lower-right, and a status `Label` in the lower-left.

image::images/layout/anchorpaneapp_mockup.png[title="AnchorPane With TextArea"]

=== Anchors

To begin the layout, create an `AnchorPane` object and add it to the `Scene`.

[source,java]
----
AnchorPane ap = new AnchorPane();
Scene scene = new Scene(ap);
----

Anchors are set using static methods of the AnchorPane class.  The methods -- one per edge -- accept the `Node` and an offset.  For the `Hyperlink`, an anchor to the top edge and an anchor to the right edge will be set.  An offset of 10.0 is set for each edge so that the link is not compressed against the side.

[source,java]
----
Hyperlink signoutLink = new Hyperlink("Sign Out");

ap.getChildren().add( signoutLink );

AnchorPane.setTopAnchor( signoutLink, 10.0d );
AnchorPane.setRightAnchor( signoutLink, 10.0d );
----

When the screen is resized, the AnchorPane will resize and signoutLink will maintain its top-right position.  Because neither the left nor bottom anchors are specified, signoutLink will not be stretched.

Next, the connection `Label` and `Circle` are added.  These controls are wrapped in an `HBox`.

[source,java]
----
Circle circle = new Circle();
circle.setFill(Color.GREEN );
circle.setRadius(10);

Label connLabel = new Label("Connection");

HBox connHBox = new HBox();
connHBox.setSpacing( 4.0d );
connHBox.setAlignment(Pos.BOTTOM_RIGHT);
connHBox.getChildren().addAll( connLabel, circle );

AnchorPane.setBottomAnchor( connHBox, 10.0d );
AnchorPane.setRightAnchor( connHBox, 10.0d );

ap.getChildren().add( connHBox );
----

As with signoutLink, connHBox is fixed to a place on the screen.  connHBox is set to be 10 pixels from the bottom edge and 10 pixels from the right edge.

The lower-left status `Label` is added.  The left and the bottom anchors are set.

[source,java]
----
Label statusLabel = new Label("Program status");
ap.getChildren().add( statusLabel );

AnchorPane.setBottomAnchor( statusLabel, 10.0d );
AnchorPane.setLeftAnchor( statusLabel, 10.0d );
----

This is a screenshot of the finished app.  The status and control labels are at the bottom of the screen, pinned to the left and right edges respectively.  The `Hyperlink` is pinned to the top-right.

image::images/layout/anchorpaneapp_default.png[title="AnchorPane App] 

=== Resizing

The controls on the periphery may vary in size. For example, a status message or a connection message may be longer.  However, the extra length can be accommodated in this layout by extending the bottom-left status `Label` to the right and by extending the bottom-right connection status `Label` to the left.  Resizing with this layout will move these controls in absolute terms, but they will adhere to their respective edges plus the offset.

That is not the case with the `TextArea`.  Because the `TextArea` may contain a lot of content, it should receive any extra space that the user gives the window.  This control will be anchored to all four corners of the `AnchorPane`.  This will cause the `TextArea` to resize when the window resizes.  The `TextArea` is fixed on the top-left and as the user drags the window handles to the bottom-right, the bottom-right corner of the `TextArea` moves as well.

This picture shows the result of two resize operations.  The top screenshot is a vertical resize from dragging the bottom edge of the window down.  The bottom screenshot is a horizontal resize from dragging the right edge of the window right.

image::images/layout/anchorpaneapp_resize.png[title="AnchorPane App Resized] 

The highlighted boxes show that the controls bordering the `TextArea` retain their positions relative to the edges.  The `TextArea` itself is resized based on the Window resize.  The top and bottom offsets of the `TextArea` account for the other controls so that they are not hidden.

[source,java]
----
TextArea ta = new TextArea();

AnchorPane.setTopAnchor( ta, 40.0d );
AnchorPane.setBottomAnchor( ta, 40.0d );
AnchorPane.setRightAnchor( ta, 10.0d );
AnchorPane.setLeftAnchor( ta, 10.0d );

ap.getChildren().add( ta );
----

`AnchorPane` is a good choice when you have a mixture of resizable and fixed-position children.  Other controls like `VBox` and `HBox` with a `Priority` setting are preferred if there is only one child needing resizing.  Use these controls instead of `AnchorPane` with a single child that has all four anchors set.  Remember that to set an anchor on a child, you use a static method of the container class such as AnchorPane.setTopAnchor().

=== Completed Code

The following is the completed code for the `AnchorPane` example.

[source,java]
----
public class AnchorPaneApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        AnchorPane ap = new AnchorPane();

        // upper-right sign out control
        Hyperlink signoutLink = new Hyperlink("Sign Out");

        ap.getChildren().add( signoutLink );

        AnchorPane.setTopAnchor( signoutLink, 10.0d );
        AnchorPane.setRightAnchor( signoutLink, 10.0d );

        // lower-left status label
        Label statusLabel = new Label("Program status");
        ap.getChildren().add( statusLabel );

        AnchorPane.setBottomAnchor( statusLabel, 10.0d );
        AnchorPane.setLeftAnchor( statusLabel, 10.0d );

        // lower-right connection status control
        Circle circle = new Circle();
        circle.setFill(Color.GREEN );
        circle.setRadius(10);

        Label connLabel = new Label("Connection");

        HBox connHBox = new HBox();
        connHBox.setSpacing( 4.0d );
        connHBox.setAlignment(Pos.BOTTOM_RIGHT);
        connHBox.getChildren().addAll( connLabel, circle );

        AnchorPane.setBottomAnchor( connHBox, 10.0d );
        AnchorPane.setRightAnchor( connHBox, 10.0d );

        ap.getChildren().add( connHBox );

        // top-left content; takes up extra space
        TextArea ta = new TextArea();
        ap.getChildren().add( ta );

        AnchorPane.setTopAnchor( ta, 40.0d );
        AnchorPane.setBottomAnchor( ta, 40.0d );
        AnchorPane.setRightAnchor( ta, 10.0d );
        AnchorPane.setLeftAnchor( ta, 10.0d );

        Scene scene = new Scene(ap);

        primaryStage.setTitle("AnchorPaneApp");
        primaryStage.setScene( scene );
        primaryStage.setWidth(568);
        primaryStage.setHeight(320);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== TilePane
Author: Carl Walker

A `TilePane` is used for grid layout of equally sized cells.  The prefColumns and the prefRows properties define the number of rows and columns in the grid.  To add Nodes to `TilePane`, access the children property and call the add() or addAll() method.  This is easier to use than `GridPane` which requires explicit setting of the row / column position of Nodes.

This screenshot shows a `TilePane` defined as a three-by-three grid.  The `TilePane` contains nine `Rectangle` objects.

image::images/layout/threebythreeapp_screenshot.png[title="A 3x3 TilePane"]

The complete code for the three-by-three grid follows.  The children property of the `TilePane` provides the addAll() method to which `Rectangle` objects are added.  The tileAlignment property positions each of the `Rectangle` objects in the center of its corresponding tile.

[source,java]
.ThreeByThreeApp.java
----
public class ThreeByThreeApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        TilePane tilePane = new TilePane();
        tilePane.setPrefColumns(3);
        tilePane.setPrefRows(3);
        tilePane.setTileAlignment( Pos.CENTER );

        tilePane.getChildren().addAll(
                new Rectangle(50, 50, Color.RED),
                new Rectangle( 50, 50, Color.GREEN ),
                new Rectangle( 50, 50, Color.BLUE ),
                new Rectangle( 50, 50, Color.YELLOW ),
                new Rectangle( 50, 50, Color.CYAN ),
                new Rectangle( 50, 50, Color.PURPLE ),
                new Rectangle( 50, 50, Color.BROWN ),
                new Rectangle( 50, 50, Color.PINK ),
                new Rectangle( 50, 50, Color.ORANGE )
        );

        Scene scene = new Scene(tilePane);
        scene.setFill(Color.LIGHTGRAY);

        primaryStage.setTitle("3x3");
        primaryStage.setScene( scene );
        primaryStage.show();
    }

    public static void main(String[] args) {launch(args);}
}
----

Since all of the `Node` contents of the `TilePane` were equally-sized Rectangles, the layout is packed together and the tileAlignment setting is not noticeable.  When the tilePrefHeight and tilePrefWidth properties are set to be larger than the contents -- say 100x100 tiles containing 50x50 Rectangles -- tileAlignment will determine how the extra space will be used.

See the following modified ThreeByThreeApp class that sets the tilePrefHeight and tilePrefWidth.

[source,java]
----
        tilePane.setPrefTileHeight(100);
        tilePane.setPrefTileWidth(100);
----

image::images/layout/threebythreeapp_screenshot_space.png[title="3x3 TilePane (Modified)"]

In the prior screenshots, nine Rectangle objects were provided to the three-by-three grid.  If the contents do not match up with the `TilePane` definition, those cells will collapse.  This modification adds only five Rectangles rather than nine.  The first row contains has content for all three tiles.  The second row has content for only the first two files.  The third row is missing entirely.

image::images/layout/threebythreeapp_screenshot_sparse.png[title="3x3 App - Sparse"]

There is a property "orientation" that instructs `TilePane` to add items row-by-row (HORIZONTAL, the default) or column-by-column (VERTICAL).  If VERTICAL is used, then the first column will have three elements, the second column will have only the top two, and the third column will be missing.  This screenshot shows the five Rectangles being added to the three-by-three grid (nine tiles) using VERTICAL orientation.

image::images/layout/threebythreeapp_screenshot_vert.png[title="3x3 App - VERTICAL"]

=== Algorithms

It is possible to create JavaFX grid layouts with other containers like `GridPane`, `VBox`, and `HBox`.  TilePane is a convenience that defines the grid layout in advance and makes adding items to the grid a simple add() or addAll() call.  Unlike a grid layout built with a combination of nested `VBox` and `HBox` containers, the `TilePane` contents are direct children.  This makes it easy to loop over the children during event processing which helps implement certain algorithms.

This example app places four Circles in a `TilePane`.  An event handler is attached to the `TilePane` which looks for a selection of one of the Circles.  If a Circle is selected, it is dimmed through the opacity setting.  If the Circle is re-selected, its original color is restored.  This screenshot shows the app with the blue `Circle` appearing purple-ish because it has been selected.

image::images/layout/tileapp.png[title="TileApp with Blue Circle Selected"]

The program begins by adding the items and setting a custom property "selected" using the Java 8 Stream API.

[source,java]
.TileApp.java
----
        TilePane tilePane = new TilePane();
        tilePane.setPrefColumns(2);
        tilePane.setPrefRows(2);
        tilePane.setTileAlignment( Pos.CENTER );

        Circle redCircle = new Circle(50, Color.RED);
        Circle greenCircle = new Circle( 50, Color.GREEN );
        Circle blueCircle = new Circle( 50, Color.BLUE );
        Circle yellowCircle = new Circle( 50, Color.YELLOW );

        List<Circle> circles = new ArrayList<>();
        circles.add( redCircle );
        circles.add( greenCircle );
        circles.add( blueCircle );
        circles.add( yellowCircle );

        circles
                .stream()
                .forEach( (c) -> c.getProperties().put( "selected", Boolean.FALSE ));

        tilePane.getChildren().addAll(
               circles
        );
----

Next, the event handler is attached to the mouse event.  This is also using Java 8 Streams.  The filter() method is determining whether or not a `Circle` is selected using the Node.contains() method on converted coordinates.  If that expression passes, findFirst() is used to retrieve the first (and in this case, only) match.  The block of code in ifPresent() sets the "selected" flag for keeping track of the `Circle` state and tweaks the opacity.

[source,java]
.TileApp.java
----
    tilePane.setOnMouseClicked(

        (evt) -> tilePane
                    .getChildren()
                    .stream()
                    .filter( c ->
                        c.contains(
                          c.sceneToLocal(evt.getSceneX(), evt.getSceneY(), true)
                        )
                     )
                    .findFirst()
                    .ifPresent(
                            (c) -> {
                                Boolean selected = (Boolean) c.getProperties().get("selected");
                                if( selected == null || selected == Boolean.FALSE ) {
                                    c.setOpacity(0.3d);
                                    c.getProperties().put("selected", Boolean.TRUE);
                                } else {
                                    c.setOpacity( 1.0d );
                                    c.getProperties().put("selected", Boolean.FALSE);
                                }
                            }
                    )
    );
----

=== Another Handler

Since the program saves the Circles in a Java Collections `List`, the `TilePane` contents can be replaced with repeated allAll() calls.  This event handler is triggered by the user pressing an "S" in the `Scene`.  The contents of the backing `List` are shuffled and re-added to the `TilePane`.

[source,java]
.TileApp.java
----
        scene.setOnKeyPressed(
                (evt) -> {
                    if( evt.getCode().equals(KeyCode.S) ) {
                        Collections.shuffle( circles );
                        tilePane.getChildren().clear();
                        tilePane.getChildren().addAll( circles );
                    }
                }
        );
----

While feasible, a grid built with VBoxes and HBoxes would be slightly more difficult because of the nested structures.  Also, `TilePane` will not stretch the contents to fill extra space, making it suitable for composite controls that need to be packed together for ergonomic reasons.

`TilePane` creates a grid based layout of equally sized cells.  Contents are added to the `TilePane` based on the prefRows, prefColumns, and orientation settings.  If the grid contains more tiles than added Nodes, there will be gaps in the layout and rows and columns may collapse if no content was provided whatsoever.  This post showed a pair of algorithms that were implemented easily because of TilePane's simply interface.

=== Complete Code

The complete code for TileApp follows.

[source,java]
.TileApp.java (Complete)
----
public class TileApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        TilePane tilePane = new TilePane();
        tilePane.setPrefColumns(2);
        tilePane.setPrefRows(2);
        tilePane.setTileAlignment( Pos.CENTER );

        Circle redCircle = new Circle(50, Color.RED);
        Circle greenCircle = new Circle( 50, Color.GREEN );
        Circle blueCircle = new Circle( 50, Color.BLUE );
        Circle yellowCircle = new Circle( 50, Color.YELLOW );

        List<Circle> circles = new ArrayList<>();
        circles.add( redCircle );
        circles.add( greenCircle );
        circles.add( blueCircle );
        circles.add( yellowCircle );

        circles
                .stream()
                .forEach( (c) -> c.getProperties().put( "selected", Boolean.FALSE ));

        tilePane.getChildren().addAll(
               circles
        );

        tilePane.setOnMouseClicked(

            (evt) -> tilePane
                        .getChildren()
                        .stream()
                        .filter( c ->
                            c.contains(
                              c.sceneToLocal(evt.getSceneX(), evt.getSceneY(), true)
                            )
                         )
                        .findFirst()
                        .ifPresent(
                                (c) -> {
                                    Boolean selected = (Boolean) c.getProperties().get("selected");
                                    if( selected == null || selected == Boolean.FALSE ) {
                                        c.setOpacity(0.3d);
                                        c.getProperties().put("selected", Boolean.TRUE);
                                    } else {
                                        c.setOpacity( 1.0d );
                                        c.getProperties().put("selected", Boolean.FALSE);
                                    }
                                }
                        )
        );

        Scene scene = new Scene(tilePane);

        scene.setOnKeyPressed(
                (evt) -> {
                    if( evt.getCode().equals(KeyCode.S) ) {
                        Collections.shuffle( circles );
                        tilePane.getChildren().clear();
                        tilePane.getChildren().addAll( circles );
                    }
                }
        );

        primaryStage.setTitle("TileApp");
        primaryStage.setScene( scene );
        primaryStage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }
}
----
