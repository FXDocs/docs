= UI Controls

== ChoiceBox
Author: Carl Walker

This article demonstrates the `ChoiceBox`.  The `ChoiceBox` control is a list of values from which the user makes a selection.  In this particular implementation, there is an empty value which makes the selection optional.

The following screenshot shows `ChoiceBox` app.  A selection "Furniture" is made and the Save `Button` is pressed.  The Save `Button` call invokes a println() which prints out the object.

image::images/ui-controls/choicebox.png[title="ChoiceBox Printing Out Selection"]

The program puts a `Label`, a `ChoiceBox`, and a `Button` into an HBox.  An action is set on the Save `Button` which prints out the value.

The simplest usage of the `ChoiceBox` is to fill it with Strings.  This `ChoiceBox` in this article is built on a JavaFX class called `Pair`.  `Pair` is a general container for any key/value pair and can be used in place of a domain or other special-purpose object.  Strings should only be used if they can be used without manipulation or decoded consistently.

[source,java]
.ChoicesApp.class
----
public class ChoicesApp extends Application {

    private final ChoiceBox<Pair<String,String>> assetClass = new ChoiceBox<>();

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label label = new Label("Asset Class:");
        assetClass.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                label,
                assetClass,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initChoice();

        saveButton.setOnAction(
                (evt) -> System.out.println("saving " + assetClass.getValue())
        );

        primaryStage.setTitle("ChoicesApp");
        primaryStage.setScene( scene );
        primaryStage.show();

    }
----

=== StringConverter

When using a complex object to back a `ChoiceBox`, a `StringConverter` is needed.  This object serializes a String to and from the `ChoiceBox`.  For this program, only the toString() needs to be coded which replaces the default toString() of the `Pair` object.  (Both toString and fromString will need an implementation in order to compile.)

An empty object EMPTY_PAIR is used to prevent NullPointerExceptions.  The returned value from assetClass().getValue() can be accessed and compared consistently without adding special null handling logic.

[source,java]
----
    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    private void initChoice() {

        List<Pair<String,String>> assetClasses = new ArrayList<>();
        assetClasses.add( new Pair("Equipment", "20000"));
        assetClasses.add( new Pair("Furniture", "21000"));
        assetClasses.add( new Pair("Investment", "22000"));

        assetClass.setConverter( new StringConverter<Pair<String,String>>() {
            @Override
            public String toString(Pair<String, String> pair) {
                return pair.getKey();
            }

            @Override
            public Pair<String, String> fromString(String string) {
                return null;
            }
        });

        assetClass.getItems().add( EMPTY_PAIR );
        assetClass.getItems().addAll( assetClasses );
        assetClass.setValue( EMPTY_PAIR );

    }
----

The ChoiceBox is used to select from a list of values.  When the list of values is a complex type, provide a StringFormatter to serialize a list object into something presentable.  If possible, use an empty object (rather than a null) to support optional values.

==== Complete Code

The code can be tested in a single .java file.

[source,java]
.ChoicesApp.class
----
public class ChoicesApp extends Application {

    private final ChoiceBox<Pair<String,String>> assetClass = new ChoiceBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label label = new Label("Asset Class:");
        assetClass.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                label,
                assetClass,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initChoice();

        saveButton.setOnAction(
                (evt) -> System.out.println("saving " + assetClass.getValue())
        );

        primaryStage.setTitle("ChoicesApp");
        primaryStage.setScene( scene );
        primaryStage.show();

    }

    private void initChoice() {

        List<Pair<String,String>> assetClasses = new ArrayList<>();
        assetClasses.add( new Pair("Equipment", "20000"));
        assetClasses.add( new Pair("Furniture", "21000"));
        assetClasses.add( new Pair("Investment", "22000"));

        assetClass.setConverter( new StringConverter<Pair<String,String>>() {
            @Override
            public String toString(Pair<String, String> pair) {
                return pair.getKey();
            }

            @Override
            public Pair<String, String> fromString(String string) {
                return null;
            }
        });

        assetClass.getItems().add( EMPTY_PAIR );
        assetClass.getItems().addAll( assetClasses );
        assetClass.setValue( EMPTY_PAIR );

    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== ComboBox
Author: Carl Walker

A `ComboBox` is a hybrid control that presents a list of values plus an edit control.  This article demonstrates a basic form of the `ComboBox` which is an un-editable list of items built on a complex data structure.

This screenshot shows a ComboBoxApp containing a list of expense accounts.  The accounts are stored in a key/value JavaFX class `Pair`.  The console shows the result of a save operation after the user selects "Auto Expense".

image::images/ui-controls/combobox.png[title="ComboBox Application"]

This code adds a Label, a ComboBox, and a Button to an HBox.  The ComboBox is instantiated as a field and initialized in a method presented later initCombo().  A handler is put on the Save Button which outputs a value if an item is selected or a special message if no item is selected.

[source,java]
.CombosApp.class
----
public class CombosApp extends Application {

    private final ComboBox<Pair<String, String>> account = new ComboBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label accountsLabel = new Label("Account:");
        account.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                accountsLabel,
                account,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initCombo();

        saveButton.setOnAction( (evt) -> {
            if( account.getValue().equals(EMPTY_PAIR) ) {
                System.out.println("no save needed; no item selected");
            } else {
                System.out.println("saving " + account.getValue());
            }
        });

        primaryStage.setTitle("CombosApp");
        primaryStage.setScene( scene );
        primaryStage.show();
    }
----

=== CellFactory

The initCombo() method adds several expense accounts to a `List`.   This `List` is added to the `ComboBox` items after an empty `Pair` object is added.  The initial value is set to the EMPTY_PAIR which is a constant.

If not specified, the `ComboBox` will use the toString() method of the object (in this article, a `Pair`) to render a backing object.  For Strings, such as a "Yes" or "No" selection, no extra code is needed.  However, the toString() of a `Pair` will output both the human-readable key and the machine-preferred value.  The requirements for this `ComboBox` are to use only the human-readable keys in the display.

To do this, a cellFactory is provided which will configure a `ListCell` object with the `Pair` key as the contents.  The `Callback` type is verbose, but the gist of the factory is set the text of a `ListCell` in the updateItem() method of an anonymous inner class.  Notice that the super class method must be called.

[source,java]
----
    private void initCombo() {

        List<Pair<String,String>> accounts = new ArrayList<>();

        accounts.add( new Pair<>("Auto Expense", "60000") );
        accounts.add( new Pair<>("Interest Expense", "61000") );
        accounts.add( new Pair<>("Office Expense", "62000") );
        accounts.add( new Pair<>("Salaries Expense", "63000") );

        account.getItems().add( EMPTY_PAIR );
        account.getItems().addAll( accounts );
        account.setValue( EMPTY_PAIR );

        Callback<ListView<Pair<String,String>>, ListCell<Pair<String,String>>> factory =
            (lv) ->
                    new ListCell<Pair<String,String>>() {
                        @Override
                        protected void updateItem(Pair<String, String> item, boolean empty) {
                            super.updateItem(item, empty);
                            if( empty ) {
                                setText("");
                            } else {
                                setText( item.getKey() );
                            }
                        }
                    };

        account.setCellFactory( factory );
        account.setButtonCell( factory.call( null ) );
    }
----

The `Callback` is used in the setButtonCell() method to provide a cell for the editing control.  Note that this program is not editable which is the default.  However, the factory.call(null) is needed otherwise only the contents of the popup menu will be properly formatted and the view of the control at rest will fallback on a toString().

This article presented a simple usage of `ComboBox`.  Since this control was not editable, `ChoiceBox` can be substituted.  For un-editable graphical renderings (ex a color coded shape for a status value), `ComboBox` still would be needed to define the specific `Node` used in the control.

==== Complete Code

The code can be tested in a single .java file.

[source,java]
.CombosApp.class
----
public class CombosApp extends Application {

    private final ComboBox<Pair<String, String>> account = new ComboBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label accountsLabel = new Label("Account:");
        account.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                accountsLabel,
                account,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initCombo();

        saveButton.setOnAction( (evt) -> {
            if( account.getValue().equals(EMPTY_PAIR ) ) {
                System.out.println("no save needed; no item selected");
            } else {
                System.out.println("saving " + account.getValue());
            }
        });

        primaryStage.setTitle("CombosApp");
        primaryStage.setScene( scene );
        primaryStage.show();
    }

    private void initCombo() {

        List<Pair<String,String>> accounts = new ArrayList<>();

        accounts.add( new Pair<>("Auto Expense", "60000") );
        accounts.add( new Pair<>("Interest Expense", "61000") );
        accounts.add( new Pair<>("Office Expense", "62000") );
        accounts.add( new Pair<>("Salaries Expense", "63000") );

        account.getItems().add( EMPTY_PAIR );
        account.getItems().addAll( accounts );
        account.setValue( EMPTY_PAIR );

        Callback<ListView<Pair<String,String>>, ListCell<Pair<String,String>>> factory =
            (lv) ->
                    new ListCell<Pair<String,String>>() {
                        @Override
                        protected void updateItem(Pair<String, String> item, boolean empty) {
                            super.updateItem(item, empty);
                            if( empty ) {
                                setText("");
                            } else {
                                setText( item.getKey() );
                            }
                        }
                    };

        account.setCellFactory( factory );
        account.setButtonCell( factory.call( null ) );
    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== ListView

=== ListView Filtering in JavaFX
Author: Carl Walker

This article demonstrates how to filter a ListView in a JavaFX Application.  Two lists are managed by the Application.  One list contains all of the items in the data model.  The second list contains the items currently being viewed.  A scrap of comparison logic stored as a filter mediates between the two.

Binding is used heavily to keep the data structures in sync with what the user has selected.

This screenshot shows the Application which contains a top row of ToggleButtons which set the filter and a ListView containing the objects.

image::images/ui-controls/listview_filtering_screenshot.png[title="Screenshot of ListView Filtering App"]

The complete code -- a single .java file -- is listed at the end of the article.

==== Data Structures

The program begins with a domain model Player and an array of Player objects.

[source,java]
----
static class Player {
	
	private final String team;
	private final String playerName;
	public Player(String team, String playerName) {
		this.team = team;
		this.playerName = playerName;
	}
	public String getTeam() {
		return team;
	}
	public String getPlayerName() {
		return playerName;
	}
	@Override
	public String toString() { return playerName + " (" + team + ")"; }
}
----

The Player class contains a pair of fields, team and playerName.  A toString() is provided so that when the object is added to the ListView (presented later), a custom ListCell class is not needed.

The test data for this example is a list of American baseball players.

[source,java]
----
Player[] players = {new Player("BOS", "David Ortiz"),
                    new Player("BOS", "Jackie Bradley Jr."),
                    new Player("BOS", "Xander Bogarts"),
                    new Player("BOS", "Mookie Betts"),
                    new Player("HOU", "Jose Altuve"),
                    new Player("HOU", "Will Harris"),
                    new Player("WSH", "Max Scherzer"),
                    new Player("WSH", "Bryce Harper"),
                    new Player("WSH", "Daniel Murphy"),
                    new Player("WSH", "Wilson Ramos") };
----

==== Model

As mentioned at the start of the article, the ListView filtering is centered around the management of two lists.  All the objects are stored in a wrapped ObservableList playersProperty and the objects that are currently viewable are stored in a wrapped FilteredList, viewablePlayersProperty.  viewablePlayersProperty is built off of playersProperty so updates made to players that meet the FilteredList criteria will also be made to viewablePlayers.

[source,java]
----
ReadOnlyObjectProperty<ObservableList<Player>> playersProperty = 
		new SimpleObjectProperty<>(FXCollections.observableArrayList());

ReadOnlyObjectProperty<FilteredList<Player>> viewablePlayersProperty =
		new SimpleObjectProperty<FilteredList<Player>>(
				new FilteredList<>(playersProperty.get()
						));
----

filterProperty() is a convenience to allow callers to bind to the underlying Predicate.  

[source,java]
----
ObjectProperty<Predicate<? super Player>> filterProperty = 
	viewablePlayersProperty.get().predicateProperty();
----

The UI root is a VBox which contains an HBox of ToggleButtons and a ListView.

[source,java]
----
VBox vbox = new VBox();
vbox.setPadding( new Insets(10));
vbox.setSpacing(4);

HBox hbox = new HBox();
hbox.setSpacing( 2 );

ToggleGroup filterTG = new ToggleGroup();
----

==== Filtering Action

A handler is attached the ToggleButtons which will modify filterProperty.  Each ToggleButton is supplied a Predicate in the userData field.  toggleHandler uses this supplied Predicate when setting the filter property.  This code sets the special case "Show All" ToggleButton.

[source,java]
----
@SuppressWarnings("unchecked")
EventHandler<ActionEvent> toggleHandler = (event) -> {
		ToggleButton tb = (ToggleButton)event.getSource();
	    Predicate<Player> filter = (Predicate<Player>)tb.getUserData();
	    filterProperty.set( filter );
	};

ToggleButton tbShowAll = new ToggleButton("Show All");
tbShowAll.setSelected(true);
tbShowAll.setToggleGroup( filterTG );	
tbShowAll.setOnAction(toggleHandler);
tbShowAll.setUserData( (Predicate<Player>) (Player p) -> true);
----

The ToggleButtons that filter a specific team are created at runtime based on the Players array.  This Stream does the following.

. Distill the list of Players down to a distinct list of team Strings
. Create a ToggleButton for each team String
. Set a Predicate for each ToggleButton to be used as a filter
. Collect the ToggleButtons for addition into the HBox container

[source,java]
----
List<ToggleButton> tbs = Arrays.asList( players)
		.stream()
		.map( (p) -> p.getTeam() )
		.distinct()
		.map( (team) -> {
			ToggleButton tb = new ToggleButton( team );
			tb.setToggleGroup( filterTG );
			tb.setOnAction( toggleHandler );
			tb.setUserData( (Predicate<Player>) (Player p) -> team.equals(p.getTeam()) );
			return tb;
		})
		.collect(Collectors.toList());

hbox.getChildren().add( tbShowAll );
hbox.getChildren().addAll( tbs );
----

==== ListView 

The next step creates the ListView and binds the ListView to the viewablePlayersProperty.  This enables the ListView to receive updates based on the changing filter.

[source,java]
----
ListView<Player> lv = new ListView<>();
lv.itemsProperty().bind( viewablePlayersProperty );
----

The remainder of the program creates a Scene and shows the Stage.  onShown loads the data set into the playersProperty and the viewablePlayersProperty lists.  Although both lists are in sync in this partcular version of the program, if the stock filter is every different than "no filter", this code would not need to be modified.

[source,java]
----
vbox.getChildren().addAll( hbox, lv );

Scene scene = new Scene(vbox);

primaryStage.setScene( scene );
		primaryStage.setOnShown((evt) -> {
			playersProperty.get().addAll( players );
		});

primaryStage.show();
----

This article used binding to tie a list of viewable Player objects to a ListView.  The viewable Players were updated when a ToggleButton is selected.  The selection applied a filter to a full set of Players which was maintained separately as a FilteredList (thanks @kleopatra_jx).  Binding was used to keep the UI in sync and to allow for a separation of concerns in the design.

==== Further Reading

To see how such a design would implement basic add and remove functionality, visit the following page https://courses.bekwam.net/public_tutorials/bkcourse_filterlistapp.php.

==== Complete Code

The code can be tested in a single .java file.

[source,java]
----
public class FilterListApp extends Application {

	@Override
	public void start(Stage primaryStage) throws Exception {
		
		//
		// Test data
		//
		Player[] players = {new Player("BOS", "David Ortiz"),
		                    new Player("BOS", "Jackie Bradley Jr."),
		                    new Player("BOS", "Xander Bogarts"),
		                    new Player("BOS", "Mookie Betts"),
		                    new Player("HOU", "Jose Altuve"),
		                    new Player("HOU", "Will Harris"),
		                    new Player("WSH", "Max Scherzer"),
		                    new Player("WSH", "Bryce Harper"),
		                    new Player("WSH", "Daniel Murphy"),
		                    new Player("WSH", "Wilson Ramos") };
		
		//
		// Set up the model which is two lists of Players and a filter criteria
		//
		ReadOnlyObjectProperty<ObservableList<Player>> playersProperty = 
				new SimpleObjectProperty<>(FXCollections.observableArrayList());
		
		ReadOnlyObjectProperty<FilteredList<Player>> viewablePlayersProperty =
				new SimpleObjectProperty<FilteredList<Player>>(
						new FilteredList<>(playersProperty.get()
								));
		
		ObjectProperty<Predicate<? super Player>> filterProperty = 
			viewablePlayersProperty.get().predicateProperty();
		

		//
		// Build the UI
		//
		VBox vbox = new VBox();
		vbox.setPadding( new Insets(10));
		vbox.setSpacing(4);
		
		HBox hbox = new HBox();
		hbox.setSpacing( 2 );
		
		ToggleGroup filterTG = new ToggleGroup();
		
		//
		// The toggleHandler action wills set the filter based on the TB selected
		//
		@SuppressWarnings("unchecked")
		EventHandler<ActionEvent> toggleHandler = (event) -> {
				ToggleButton tb = (ToggleButton)event.getSource();
			    Predicate<Player> filter = (Predicate<Player>)tb.getUserData();
			    filterProperty.set( filter );
			};
		
		ToggleButton tbShowAll = new ToggleButton("Show All");
		tbShowAll.setSelected(true);
		tbShowAll.setToggleGroup( filterTG );	
		tbShowAll.setOnAction(toggleHandler);
		tbShowAll.setUserData( (Predicate<Player>) (Player p) -> true);
		
		//
		// Create a distinct list of teams from the Player objects, then create
		// ToggleButtons
		//
		List<ToggleButton> tbs = Arrays.asList( players)
				.stream()
				.map( (p) -> p.getTeam() )
				.distinct()
				.map( (team) -> {
					ToggleButton tb = new ToggleButton( team );
					tb.setToggleGroup( filterTG );
					tb.setOnAction( toggleHandler );
					tb.setUserData( (Predicate<Player>) (Player p) -> team.equals(p.getTeam()) );
					return tb;
				})
				.collect(Collectors.toList());
		
		hbox.getChildren().add( tbShowAll );
		hbox.getChildren().addAll( tbs );
		
		//
		// Create a ListView bound to the viewablePlayers property
		//
		ListView<Player> lv = new ListView<>();
		lv.itemsProperty().bind( viewablePlayersProperty );
		
		vbox.getChildren().addAll( hbox, lv );
		
		Scene scene = new Scene(vbox);
		
		primaryStage.setScene( scene );
		primaryStage.setOnShown((evt) -> {
			playersProperty.get().addAll( players );
		});
		
		primaryStage.show();
		
	}

	public static void main(String args[]) {
		launch(args);
	}
	
	static class Player {
		
		private final String team;
		private final String playerName;
		public Player(String team, String playerName) {
			this.team = team;
			this.playerName = playerName;
		}
		public String getTeam() {
			return team;
		}
		public String getPlayerName() {
			return playerName;
		}
		@Override
		public String toString() { return playerName + " (" + team + ")"; }
	}
}
----

== TableView
Author: Carl Walker

For JavaFX business applications, the `TableView` is an essential control.  Use a `TableView` when you need to present multiple records in a flat row/column structure.  This example shows the basic elements of a `TableView` and demonstrates the power of the component when JavaFX Binding is applied.

The demonstration app is a `TableView` and a pair of Buttons.  The `TableView` has four TableColumns: SKU, Item, Price, Tax.  The `TableView` shows three objects in three rows: Mechanical Keyboard, Product Docs, O-Rings.  The following screenshot shows the app immediately after startup.

image::images/ui-controls/tableviewselectapp_screenshot.png[title="Intial View of Demo App"]

The disabled logic of the Buttons is based on the selections in the `TableView`.  Initially, no items are selected so both Buttons are disabled.  If any item is selected -- the first item in the following screenshot -- the Inventory `Button` is enabled.  The Tax `Button` is also enabled although that requires consulting the Tax value.

image::images/ui-controls/tableviewselectapp_screenshot_selected_tax.png[title="With Taxable Item Selected"]

If the Tax value for the selected item is false, then the Tax `Button` will be disabled.  This screenshot shows the second item selected.  The Inventory `Button` is enabled but the Tax `Button` is not.

image::images/ui-controls/tableviewselectapp_screenshot_selected_notax.png[title="A Non-Taxable Item Disables the Tax Button"]

=== Model and Declarations

A `TableView` is based on a model which is a POJO called Item.

[source,java]
.Item.java
----
public class Item {

    private final String sku;
    private final String descr;
    private final Float price;
    private final Boolean taxable;

    public Item(String sku, String descr, Float price, Boolean taxable) {
        this.sku = sku;
        this.descr = descr;
        this.price = price;
        this.taxable = taxable;
    }

    public String getSku() {
        return sku;
    }

    public String getDescr() {
        return descr;
    }

    public Float getPrice() {
        return price;
    }

    public Boolean getTaxable() {
        return taxable;
    }
}
----

The `TableView` and `TableColumn` use generics in their declarations.  For `TableView`, the type parameter is Item.  For the TableColumns, the type parameters are Item and the field type.  The constructor of `TableColumn` accepts a column name.  In this example, the column names diverge slightly from the actual field names.

[source,java]
.TableSelectApp.java
----
        TableView<Item> tblItems = new TableView<>();

        TableColumn<Item, String> colSKU = new TableColumn<>("SKU");
        TableColumn<Item, String> colDescr = new TableColumn<>("Item");
        TableColumn<Item, Float> colPrice = new TableColumn<>("Price");
        TableColumn<Item, Boolean> colTaxable = new TableColumn<>("Tax");

        tblItems.getColumns().addAll(
            colSKU, colDescr, colPrice, colTaxable
        );
----

Adding model items to the `TableView` is done by adding items to the underlying collection.

[source,java]
.TableSelectApp.java
----
        tblItems.getItems().addAll(
            new Item("KBD-0455892", "Mechanical Keyboard", 100.0f, true),
            new Item( "145256", "Product Docs", 0.0f, false ),
            new Item( "OR-198975", "O-Ring (100)", 10.0f, true)
        );
----

At this point, the `TableView` has been configured and test data has been added.  However, if you were to view the program, you would see three empty rows.  That is because JavaFX is missing the linkage between the POJO and the TableColumns.  That linkage is added to the TableColumns using a cellValueFactory.

[source,java]
.TableSelectApp.java
----
        colSKU.setCellValueFactory( new PropertyValueFactory<>("sku") );
        colDescr.setCellValueFactory( new PropertyValueFactory<>("descr") );
        colPrice.setCellValueFactory( new PropertyValueFactory<>("price") );
        colTaxable.setCellValueFactory( new PropertyValueFactory<>("taxable") );
----

Viewing the program at this point will display the data in the appropriate columns.

=== Selection

To retrieve the selected item or items in a `TableView`, use the separate selectionModel object.  Calling tblItems.getSelectionModel() returns an object that includes a property "selectedItem".  This can be retrieved and used in a method, say to bring up an edit details screen.  Alternatively, getSelectionModel() can return a JavaFX property "selectedItemProperty" for binding expressions.

In the demo app, two Buttons are bound to the selectionModel of the `TableView`.  Without binding, you might add listeners that examine the selection and make a call like setDisabled() on a Button.  Prior to the `TableView` selection, you would also need initialization logic to handle the case where there is no selection.  The binding syntax expresses this logic in a declarative statement that can handle both the listener and the initialization in a single line.

[source,java]
.TableSelectApp.java
----
        Button btnInventory = new Button("Inventory");
        Button btnCalcTax = new Button("Tax");

        btnInventory.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull() <1>
        );
----

<1> See "Ignoring Warnings for Null Select Binding Expressions" under "Best Practices" to show how to turn off warning messages when using this construct

The btnInventory disable property will be true if there is no item selected (isNull()).  When the screen is first displayed, no selection is made and the `Button` is disabled.  Once any selection is made, btnInventory is enabled (disable=false).

the btnCalcTax logic is slightly more complex.  btnCalcTax too is disabled when there is no selection.  However, btnCalcTax will also consider the contents of the selectedItem.  A composite binding or() is used to join these two conditions.  As before, there is an isNull() expression for no selection.  The Bindings.select() checks the value of Item.taxable.  A true taxable Item will enable btnCalcTax while a false item will disable the `Button`.

[source,java]
.TableSelectApp.java
----
        btnCalcTax.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull().or(
                    Bindings.select(
                        tblItems.getSelectionModel().selectedItemProperty(),
                        "taxable"
                    ).isEqualTo(false)
            )
        );
----

Bindings.select() is the mechanism to extract a field from an object.  selectedItemProperty() is the changing selectedItem and "taxable" is the single-hop path to the taxable field.

This example showed how to set up a `TableView` based on a POJO.  It also featured a pair of powerful binding expressions that allow you to link related controls without writing extra listeners and initialization code.  The `TableView` is an indispensable control for the JavaFX business applications developer.  It will be the best and most familiar control for displaying a list of structured items.

=== Complete Code

The complete code for the application follows.  It is a pair of class files TableSelectApp.java and Item.java.  Item.java was already presented in its entirety in an earlier section.

[source,java]
.TableSelectApp.java
----
public class TableSelectApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        TableView<Item> tblItems = new TableView<>();
        tblItems.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        VBox.setVgrow(tblItems, Priority.ALWAYS );

        TableColumn<Item, String> colSKU = new TableColumn<>("SKU");
        TableColumn<Item, String> colDescr = new TableColumn<>("Item");
        TableColumn<Item, Float> colPrice = new TableColumn<>("Price");
        TableColumn<Item, Boolean> colTaxable = new TableColumn<>("Tax");

        colSKU.setCellValueFactory( new PropertyValueFactory<>("sku") );
        colDescr.setCellValueFactory( new PropertyValueFactory<>("descr") );
        colPrice.setCellValueFactory( new PropertyValueFactory<>("price") );
        colTaxable.setCellValueFactory( new PropertyValueFactory<>("taxable") );

        tblItems.getColumns().addAll(
            colSKU, colDescr, colPrice, colTaxable
        );

        tblItems.getItems().addAll(
            new Item("KBD-0455892", "Mechanical Keyboard", 100.0f, true),
            new Item( "145256", "Product Docs", 0.0f, false ),
            new Item( "OR-198975", "O-Ring (100)", 10.0f, true)
        );

        Button btnInventory = new Button("Inventory");
        Button btnCalcTax = new Button("Tax");

        btnInventory.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull()
        );

        btnCalcTax.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull().or(
                    Bindings.select(
                        tblItems.getSelectionModel().selectedItemProperty(),
                        "taxable"
                    ).isEqualTo(false)
            )
        );

        HBox buttonHBox = new HBox( btnInventory, btnCalcTax );
        buttonHBox.setSpacing( 8 );

        VBox vbox = new VBox( tblItems, buttonHBox );
        vbox.setPadding( new Insets(10) );
        vbox.setSpacing( 10 );

        Scene scene = new Scene(vbox);

        primaryStage.setTitle("TableSelectApp");
        primaryStage.setScene( scene );
        primaryStage.setHeight( 376 );
        primaryStage.setWidth( 667 );
        primaryStage.show();
    }

    public static void main(String[] args) {

        launch(args);
    }
}
----